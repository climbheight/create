#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#define BLOCK_SIZE 2

// 定义双向块链节点结构体
typedef struct BlockNode {
    char data[BLOCK_SIZE];
    struct BlockNode *prev;
    struct BlockNode *next;
} BlockNode;

// 创建新节点
BlockNode* createNode(const char *s, int start) {
    BlockNode *node = (BlockNode *)malloc(sizeof(BlockNode));
    int i;
    for (i = 0; i < BLOCK_SIZE && s[start + i]; i++) {
        node->data[i] = s[start + i];
    }
    while (i < BLOCK_SIZE) {
        node->data[i++] = '\0';
    }
    node->prev = NULL;
    node->next = NULL;
    return node;
}

// 初始化双向块链字符串
BlockNode* initBlockChain(const char *s) {
    BlockNode *head = NULL, *tail = NULL;
    for (int i = 0; s[i]; i += BLOCK_SIZE) {
        BlockNode *newNode = createNode(s, i);
        if (!head) {
            head = tail = newNode;
        } else {
            tail->next = newNode;
            newNode->prev = tail;
            tail = newNode;
        }
    }
    return head;
}

// 计算字符串长度
int getLength(const char *s) {
    int len = 0;
    while (s[len]) len++;
    return len;
}

// 判断双向块链字符串是否对称
int isSymmetric(BlockNode *head, BlockNode *tail, int len) {
    int leftIndex = 0;
    int rightIndex = BLOCK_SIZE - 1;
    // 先找到最后一个块链实际存储字符的最后位置
    while (rightIndex >= 0 && tail->data[rightIndex] == '\0') {
        rightIndex--;
    }
    int remaining = len;
    while (remaining > 1) {
        if (head->data[leftIndex] != tail->data[rightIndex]) {
            return 0;
        }
        remaining -= 2;

        leftIndex++;
        rightIndex--;

        // 处理左指针移动
        if (leftIndex == BLOCK_SIZE || head->data[leftIndex] == '\0') {
            head = head->next;
            leftIndex = 0;
        }
        // 处理右指针移动
        if (rightIndex < 0) {
            tail = tail->prev;
            if (tail) {
                rightIndex = BLOCK_SIZE - 1;
                // 找到当前右节点实际存储字符的最后位置
                while (rightIndex >= 0 && tail->data[rightIndex] == '\0') {
                    rightIndex--;
                }
            }
        }
    }
    return 1;
}

// 释放双向链表内存
void freeList(BlockNode *head) {
    BlockNode *temp;
    while (head) {
        temp = head;
        head = head->next;
        free(temp);
    }
}

int main() {
    const char *s = "abccba";
    BlockNode *head = initBlockChain(s);
    BlockNode *tail = head;
    while (tail && tail->next) {
        tail = tail->next;
    }
    int len = getLength(s);
    if (isSymmetric(head, tail, len)) {
        printf("字符串是对称的\n");
    } else {
        printf("字符串不是对称的\n");
    }
    freeList(head);
    return 0;
}
